#### 介绍
1. 动态规划(Dynamic Programming)算法的核心思想是：将大问题划分为小问题进行解决，从而一步步获取最优解的处理算法
2. 动态规划算法与分治算法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。
3. 与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。 ( 即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解 )
4. 动态规划可以通过填表的方式来逐步推进，得到最优解.

#### 背包问题
背包问题：有一个背包，容量为4磅 ， 现有如下物品


物品 | 重量 | 价格
---|---|---
吉他 | 1 | 1500
音箱 | 4 | 3000
电脑 | 3 | 2000
1. 要求达到的目标为装入的背包的总价值最大，并且重量不超出
2. 要求装入的物品不能重复

#### 代码实现
```java
/**
 * 简单背包问题
 * 1. 多个物品 有重量以及价值
 * 2. 背包固定重量，求放入背包的物品的最高价值，物品不能重复
 */
public class KnapsackProblem {
	public static void main(String[] args) {
		int[] val = {1500,3000,2000}; // 物品价值，下标第几个物品
		int[] w = {1,4,3}; // 物品重量
		int m = 4; // 背包容量
		int n = val.length;
		// v[i][j]代表的是 j容量的时候能存放的最大的价值
		// i 第几个物品  j 递增的容量,不超过背包最大容量
		int[][] v = new int[n + 1][m + 1];
		// 二维数组的第一行和第一列不存放价值，默认为0，为了保证算法不越界
		for (int i = 1; i < v.length; i++) {
			for (int j = 1; j < v[0].length; j++) {
				if(w[i-1] > j){ // 如果当前物品重量比当前容量大，直接取上一个物品的时候的最大价值
					v[i][j] = v[i - 1][j];
				}else { // 小于的时候，需要将当前最大值与之前的最大价值进行比较
					v[i][j] = Math.max(v[i-1][j],val[i - 1] + v[i-1][j - w[i - 1]]);
				}
			}
		}

		for (int[] ints : v) {
			System.out.println(Arrays.toString(ints));
		}
	}
}
```
#### 阶梯问题
有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。
#### 代码实现
```java
/**
 * 有一座高度是10级台阶的楼梯，从下往上走，每跨一步只能向上1级或者2级台阶。要求用程序来求出一共有多少种走法。
 * 1. 可以逆向思维，当最后已有一阶台阶的时候只有一种走法
 * 2. 两阶台阶有两种走法
 * 3. f(10) = f(9) + f(8),由于最后一阶台阶与最后两阶台阶可以分为两部分即f(9)与f(8),十个台阶的走法就为8个台阶月9个台阶走法之和
 * 4. 一次类推
 */
public class StepProblem {

	public static void main(String[] args) {
		System.out.println(step2(10));
	}

	// 用递归解决
	// 使用这种方式会进行多次不必要的计算
	public static int step1(int n){
		if(n < 1){
			return 0;
		}
		if(n == 1){
			return 1;
		}
		if(n == 2){
			return 2;
		}
		return step1(n-1)+step1(n-2);
	}

	// 使用动态规划
	public static int step2(int n){
		if(n < 1){
			return 0;
		}
		if(n == 1){
			return 1;
		}
		if(n == 2){
			return 2;
		}
		int a = 1;
		int b = 2;
		int temp = 0;
		for (int i = 3; i <= n; i++) {
			temp = a + b;
			a = b;
			b = temp;
		}
		return temp;
	}
}

```
